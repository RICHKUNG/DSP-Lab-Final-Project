<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ECG Pulse Runner</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <style>
        body {
            margin: 0;
            padding: 28px;
            background: radial-gradient(circle at 20% 20%, #041204 0%, #010a01 35%, #000 70%);
            color: #0f0;
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            box-sizing: border-box;
        }
        #monitor {
            position: relative;
            width: min(1200px, 96vw);
            height: min(70vw, 720px);
            background: linear-gradient(140deg, #010f01 0%, #002400 55%, #000 100%);
            border: 2px solid #0f0;
            border-radius: 14px;
            box-shadow: 0 0 28px rgba(0, 255, 0, 0.35);
            overflow: hidden;
            padding: 18px 22px 26px;
            box-sizing: border-box;
        }
        canvas {
            position: absolute;
            inset: 12px;
            width: calc(100% - 24px);
            height: calc(100% - 24px);
            background: #000;
            border: 1px solid #085;
            border-radius: 10px;
            z-index: 1;
        }
        /* UI ?????????? */
        .ui-layer {
            position: absolute;
            top: 18px;
            left: 28px;
            right: 28px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
            padding: 10px 14px;
            background: rgba(0, 24, 0, 0.7);
            border: 1px solid #0a4;
            border-radius: 10px;
            font-size: 22px;
            font-weight: bold;
            pointer-events: none;
            letter-spacing: 1px;
            z-index: 5;
        }
        .ui-layer .stat {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            color: #c8ffc8;
        }
        .ui-layer .stat.bpm {
            font-size: 30px;
            color: #ff4d4d;
            text-shadow: 0 0 12px rgba(255, 0, 0, 0.85);
        }
        .ui-layer .stat .icon {
            font-size: 20px;
            color: #0f0;
            text-shadow: 0 0 8px rgba(0, 255, 0, 0.7);
        }
        #controls-toggle {
            position: absolute;
            bottom: 22px;
            right: 24px;
            z-index: 8;
            background: rgba(0, 80, 0, 0.9);
            color: #c8ffc8;
            border: 1px solid #0a4;
            border-radius: 8px;
            padding: 8px 14px;
            font-size: 12px;
            letter-spacing: 1px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.35);
            transition: background 0.2s ease, color 0.2s ease;
        }
        #controls-toggle:hover {
            background: rgba(0, 110, 0, 0.95);
            color: #fff;
        }

        /* Controls Instructions */
        .controls-box {
            position: absolute;
            bottom: 70px;
            right: 28px;
            width: 280px;
            max-width: 32%;
            background: rgba(0, 24, 0, 0.82);
            border: 1px solid #0a4;
            padding: 18px 18px 14px;
            color: #b6ffb6;
            font-size: 14px;
            line-height: 1.7;
            z-index: 6;
            pointer-events: auto;
            border-radius: 12px;
            box-shadow: 0 10px 26px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(2px);
            transition: transform 0.25s ease, opacity 0.25s ease;
            max-height: 60%;
            overflow-y: auto;
        }
        .controls-box.collapsed {
            transform: translateX(85%);
            opacity: 0.25;
            pointer-events: none;
        }
        .controls-box h3 { margin: 0 0 12px 0; color: #fff; font-size: 15px; border-bottom: 1px solid #0a4; padding-bottom: 6px; letter-spacing: 0.5px; }
        .controls-box ul { padding-left: 18px; margin: 0; }
        .controls-box > div { margin-bottom: 18px; }

        /* ?????????????? */
        #status {
            position: absolute;
            top: 24px;
            right: 34px;
            font-size: 12px;
            color: #0a0;
            z-index: 10;
            letter-spacing: 0.5px;
        }
        .connected { color: #0f0 !important; }

        /* ??????? */
        #debug-log {
            position: absolute;
            bottom: 26px;
            left: 26px;
            width: 320px;
            height: 110px;
            overflow-y: auto;
            font-size: 12px;
            color: #8f8;
            background: rgba(0,0,0,0.6);
            border: 1px solid #0f0;
            padding: 10px;
            z-index: 10;
            pointer-events: auto;
            border-radius: 8px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.35);
        }

        .overlay {
            position: absolute;
            top: 50%;
            left: 56%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 20, 0, 0.95);
            border: 2px solid #0f0;
            padding: 26px 32px;
            z-index: 20;
            max-width: 420px;
            width: min(420px, 70vw);
            border-radius: 12px;
            box-shadow: 0 14px 40px rgba(0, 0, 0, 0.55);
        }
        #gameOverScreen { left: 50%; }
        button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 14px 36px;
            font-size: 17px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
            border-radius: 6px;
            box-shadow: 0 6px 18px rgba(0, 255, 0, 0.25);
        }
        button:hover { background: #0d0; }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div id="monitor">
        <canvas id="gameCanvas"></canvas>

        <button id="controls-toggle" type="button">HELP</button>

        <div class="ui-layer">
            <div class="stat bpm"><span class="icon">&#10084;</span> BPM: <span id="bpm">--</span></div>
            <div class="stat dist">DIST: <span id="dist">0m</span></div>
        </div>

        <div class="controls-box collapsed">
            <h3>ğŸ® éŠæˆ²æ§åˆ¶ (CONTROLS)</h3>
            <div style="margin-bottom: 10px;">
                <strong style="color: #ffff00;">ğŸ¤ èªéŸ³ (Voice):</strong>
                <ul>
                    <li><strong>"é–‹å§‹" (START)</strong>: é–‹å§‹éŠæˆ²</li>
                    <li><strong>"è·³" (JUMP)</strong>: è·³èº</li>
                    <li><strong>"ç¿»" (FLIP)</strong>: ç¿»è½‰åˆ°å¦ä¸€å´</li>
                    <li><strong>"æš«åœ" (PAUSE)</strong>: æš«åœ/ç¹¼çºŒ</li>
                </ul>
            </div>
            <div>
                <strong style="color: #00ffff;">âŒ¨ï¸ éµç›¤ (Keyboard):</strong>
                <ul>
                    <li><strong>[â†‘]</strong>: è·³èº</li>
                    <li><strong>[â†“]</strong>: ç¿»è½‰åˆ°å¦ä¸€å´</li>
                    <li><strong>[Enter]</strong>: é–‹å§‹</li>
                    <li><strong>[Space]</strong>: æš«åœ</li>
                </ul>
            </div>
        </div>

        <div id="status">â—‹ WAIT FOR SIGNAL...</div>
        <div id="debug-log">Debug Log initialized...</div>

        <div id="startScreen" class="overlay">
            <h1>ECG PULSE RUNNER</h1>
            <p>èªéŸ³æ§åˆ¶ + ECG å¿ƒé›»åœ–</p>
            <p style="font-size: 14px;">
                èªéŸ³æŒ‡ä»¤: é–‹å§‹ / è·³ / ç¿» / æš«åœ<br>
                éµç›¤: Enter (é–‹å§‹) / â†‘ (è·³) / â†“ (ç¿») / Space (æš«åœ)
            </p>
            <button onclick="startGame()">START GAME</button>
        </div>

        <div id="gameOverScreen" class="overlay hidden">
            <h1 style="color:#f33">GAME OVER</h1>
            <p>è·é›¢: <span id="finalDist"></span>m</p>
            <button onclick="startGame()">RESTART</button>
        </div>
    </div>

    <script>
        // Controls panel toggle to keep instructions from covering gameplay
        const controlsBox = document.querySelector('.controls-box');
        const controlsToggle = document.getElementById('controls-toggle');
        function setControlsOpen(open) {
            controlsBox.classList.toggle('collapsed', !open);
            controlsToggle.textContent = open ? 'CLOSE HELP' : 'HELP';
        }
        controlsToggle.addEventListener('click', () => {
            const open = controlsBox.classList.contains('collapsed');
            setControlsOpen(open);
        });
        setControlsOpen(false);

        function log(msg) {
            const el = document.getElementById('debug-log');
            const line = document.createElement('div');
            line.textContent = `> ${msg}`;
            el.appendChild(line);
            el.scrollTop = el.scrollHeight;
            console.log(msg);
        }

        // Socket.IO é€£ç·š
        const socket = io();
        const statusEl = document.getElementById('status');

        socket.on('connect', () => {
            statusEl.textContent = 'â— CONNECTED';
            statusEl.classList.add('connected');
            log('Socket connected');
        });

        socket.on('disconnect', () => {
            statusEl.textContent = 'â—‹ DISCONNECTED';
            statusEl.classList.remove('connected');
            log('Socket disconnected');
        });

        socket.on('connect_error', (error) => {
            log(`Connection Error: ${error}`);
        });

        // éŠæˆ²ç‹€æ…‹
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let width, height, centerY;
        let isRunning = false;
        let isPaused = false;
        let score = 0;
        let gameSpeed = 8; // Accelerated from 6
        let obstacles = [];

        // ç©å®¶
        const player = {
            x: 100,
            y: 0,
            size: 24,  // Slightly larger for ECG pulse block
            dy: 0,
            isOnTop: true,
            jumpCount: 0,
            maxJumps: 2,
            pulsePhase: 0,  // For ECG pulse animation

            update() {
                const gravityDir = this.isOnTop ? 1 : -1;
                const groundY = this.isOnTop ? centerY - this.size : centerY;

                // Stronger gravity for snappier jumps (was 0.5)
                this.dy += 1.0 * gravityDir;
                this.y += this.dy;

                // è½åœ°
                if (this.isOnTop) {
                    if (this.y > groundY) {
                        this.y = groundY;
                        this.dy = 0;
                        this.jumpCount = 0;
                    }
                } else {
                    if (this.y < groundY) {
                        this.y = groundY;
                        this.dy = 0;
                        this.jumpCount = 0;
                    }
                }

                // Update pulse animation
                this.pulsePhase = (this.pulsePhase + 0.15) % (Math.PI * 2);
            },

            draw() {
                // ECG-themed heart pulse block with glow
                const glowIntensity = 0.3 + Math.sin(this.pulsePhase) * 0.2;

                // Outer glow
                ctx.shadowBlur = 15;
                ctx.shadowColor = `rgba(255, 60, 60, ${glowIntensity})`;

                // Main block - ECG red with gradient
                const gradient = ctx.createLinearGradient(this.x, this.y, this.x + this.size, this.y + this.size);
                gradient.addColorStop(0, '#ff4d4d');
                gradient.addColorStop(0.5, '#ff1a1a');
                gradient.addColorStop(1, '#cc0000');

                ctx.fillStyle = gradient;
                ctx.fillRect(this.x, this.y, this.size, this.size);

                // Inner highlight
                ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + glowIntensity * 0.3})`;
                ctx.fillRect(this.x + 2, this.y + 2, this.size - 4, 4);

                // ECG line pattern on block
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.6 + glowIntensity * 0.4})`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                const cx = this.x + this.size / 2;
                const cy = this.y + this.size / 2;
                ctx.moveTo(cx - 8, cy);
                ctx.lineTo(cx - 4, cy);
                ctx.lineTo(cx - 3, cy - 6);
                ctx.lineTo(cx - 1, cy + 4);
                ctx.lineTo(cx + 1, cy - 2);
                ctx.lineTo(cx + 3, cy);
                ctx.lineTo(cx + 8, cy);
                ctx.stroke();

                // Reset shadow
                ctx.shadowBlur = 0;
            },

            jump() {
                if (this.jumpCount < this.maxJumps) {
                    // Increased jump force (was 10)
                    this.dy = 22 * (this.isOnTop ? -1 : 1);
                    this.jumpCount++;
                }
            },

            flip() {
                // Flip player to opposite side of baseline
                this.isOnTop = !this.isOnTop;
                const newGroundY = this.isOnTop ? centerY - this.size : centerY;
                this.y = newGroundY;
                this.dy = 0;
                this.jumpCount = 0;
            }
        };

        // éšœç¤™ç‰©
        class Obstacle {
            constructor(dir, height) {
                this.x = width;
                this.dir = dir; // 1 (ä¸‹) æˆ– -1 (ä¸Š)
                this.height = Math.min(Math.max(height, 20), 80);
                this.width = 15; // Adjusted for thinner obstacles, lowering difficulty
                this.markedForDeletion = false;
                this.pulseOffset = Math.random() * Math.PI * 2; // Random pulse phase
            }

            update() {
                this.x -= gameSpeed;
                if (this.x + this.width < -100) this.markedForDeletion = true;
            }

            draw() {
                // ECG-themed spike obstacles with pulsing glow
                const pulseGlow = 0.4 + Math.sin(Date.now() * 0.005 + this.pulseOffset) * 0.3;

                // Shadow/glow effect
                ctx.shadowBlur = 12;
                ctx.shadowColor = `rgba(0, 255, 0, ${pulseGlow})`;

                if (this.dir === 1) {
                    // ä¸‹æ–¹éšœç¤™ - ECG spike going down
                    const baseY = centerY;

                    // Gradient for depth
                    const gradient = ctx.createLinearGradient(this.x, baseY, this.x, baseY + this.height);
                    gradient.addColorStop(0, '#0f0');
                    gradient.addColorStop(0.3, '#0d0');
                    gradient.addColorStop(1, '#0a0');

                    ctx.fillStyle = gradient;

                    // Draw spike shape
                    ctx.beginPath();
                    ctx.moveTo(this.x, baseY);
                    ctx.lineTo(this.x + this.width / 2, baseY + this.height);
                    ctx.lineTo(this.x + this.width, baseY);
                    ctx.closePath();
                    ctx.fill();

                    // Highlight edge
                    ctx.strokeStyle = `rgba(180, 255, 180, ${0.7 + pulseGlow * 0.3})`;
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                } else {
                    // ä¸Šæ–¹éšœç¤™ - ECG spike going up
                    const baseY = centerY;

                    // Gradient for depth
                    const gradient = ctx.createLinearGradient(this.x, baseY, this.x, baseY - this.height);
                    gradient.addColorStop(0, '#0f0');
                    gradient.addColorStop(0.3, '#0d0');
                    gradient.addColorStop(1, '#0a0');

                    ctx.fillStyle = gradient;

                    // Draw spike shape
                    ctx.beginPath();
                    ctx.moveTo(this.x, baseY);
                    ctx.lineTo(this.x + this.width / 2, baseY - this.height);
                    ctx.lineTo(this.x + this.width, baseY);
                    ctx.closePath();
                    ctx.fill();

                    // Highlight edge
                    ctx.strokeStyle = `rgba(180, 255, 180, ${0.7 + pulseGlow * 0.3})`;
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }

                // Reset shadow
                ctx.shadowBlur = 0;
            }

            collidesWith(p) {
                // Proper AABB Collision
                const obsX = this.x;
                const obsY = (this.dir === 1) ? centerY : centerY - this.height;
                const obsW = this.width;
                const obsH = this.height;

                const pX = p.x;
                const pY = p.y;
                const pS = p.size;

                // Check overlap
                // 1. Horizontal
                if (pX < obsX + obsW && pX + pS > obsX) {
                    // 2. Vertical
                    if (pY < obsY + obsH && pY + pS > obsY) {
                        return true;
                    }
                }
                return false;
            }
        }

        // æ¥æ”¶äº‹ä»¶
        socket.on('spawn_obstacle', (data) => {
            if (!isRunning || isPaused) return;
            // log(`Spawn obstacle: ${data.dir}`);
            obstacles.push(new Obstacle(data.dir, data.height));
        });

        socket.on('player_action', (data) => {
            log(`Action received: ${data.action}`);
            const action = (data.action || '').toUpperCase().trim();

            // å„ªå…ˆè™•ç† START
            if (action === 'START') {
                if (!isRunning) {
                    startGame();
                } else if (isPaused) {
                    // Fix: START also resumes game
                    isPaused = false;
                    log("Game Resumed (via START)");
                }
                return;
            }

            if (!isRunning) return;

            if (action === 'JUMP' && !isPaused) {
                player.jump();
            } else if (action === 'PAUSE') {
                isPaused = !isPaused;
                log(isPaused ? "Game Paused" : "Game Resumed");
            } else if (action === 'FLIP' && !isPaused) {
                player.flip();
                log("Player flipped!");
            }
        });

        socket.on('bpm_update', (data) => {
            const bpm = Math.round(data.bpm);
            document.getElementById('bpm').textContent = bpm;
            
            // Dynamic Speed Adjustment based on BPM
            // Map BPM 60 -> Speed 6, BPM 100 -> Speed 10
            // Clamped between 5 (min) and 13 (max)
            if (bpm > 30) {
                let newSpeed = bpm / 10;
                // Clamp speed to keep game playable
                gameSpeed = Math.max(5, Math.min(13, newSpeed));
            }
        });

        // éµç›¤æ§åˆ¶
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp') {
                if (isRunning && !isPaused) player.jump();
            } else if (e.key === 'ArrowDown') {
                if (isRunning && !isPaused) player.flip();
            } else if (e.key === ' ' || e.key === 'p') {
                isPaused = !isPaused;
                log("Pause toggle key pressed");
            } else if (e.key === 'Enter') {
                if (!isRunning) startGame();
            }
        });

        // åˆå§‹åŒ–
        function resize() {
            width = canvas.width = canvas.offsetWidth;
            height = canvas.height = canvas.offsetHeight;
            centerY = height / 2;
            player.y = centerY - player.size;
        }

        function startGame() {
            log("Starting Game...");
            document.getElementById('startScreen').classList.add('hidden');
            document.getElementById('gameOverScreen').classList.add('hidden');

            isRunning = true;
            isPaused = false;
            score = 0;
            obstacles = [];
            player.y = centerY - player.size;
            player.dy = 0;
            player.jumpCount = 0;
            player.isOnTop = true; // é‡ç½®ä½ç½®

            gameLoop();
        }

        function gameOver() {
            log("Game Over");
            isRunning = false;
            document.getElementById('finalDist').textContent = Math.floor(score / 10);
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }

        function gameLoop() {
            if (!isRunning) return;

            // æ¸…ç©º
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);

            // ä¸­ç·š
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();

            if (!isPaused) {
                // æ›´æ–°
                player.update();
                obstacles.forEach(o => o.update());
                obstacles = obstacles.filter(o => !o.markedForDeletion);

                // ç¢°æ’æª¢æ¸¬
                for (let obs of obstacles) {
                    if (obs.collidesWith(player)) {
                        gameOver();
                        return;
                    }
                }

                score++;
            } else {
                ctx.fillStyle = "white";
                ctx.font = "30px Courier New";
                ctx.fillText("PAUSED", width/2 - 50, height/2 - 40);
            }

            // ç¹ªè£½
            player.draw();
            obstacles.forEach(o => o.draw());

            document.getElementById('dist').textContent = Math.floor(score / 10) + 'm';

            requestAnimationFrame(gameLoop);
        }

        window.addEventListener('resize', resize);
        resize();
    </script>
</body>
</html>
